// user-defined properties

// used to distinguish 6 different types of addrmap:
// reg_network, regmst, regdisp, regslv, 3rd party IP, flatten addrmap
property hj_gennetwork {
    component = addrmap;
    type = boolean;
};
property hj_genmst {
    component = addrmap;
    type = boolean;
};
property hj_gendisp {
    component = addrmap;
    type = boolean;
};
property hj_genslv {
    component = addrmap;
    type = boolean;
};
property hj_3rd_party_ip {
    component = addrmap;
    type = boolean;
};
property hj_flatten_addrmap {
    component = addrmap;
    type = boolean;
};

// synchronous reset signals for fields
property hj_syncresetsignal {
    component = field;
    type = string;
};

// whether this module needs clock domain crossing (CDC)
property hj_cdc {
    component = addrmap | mem;
    type = boolean;
};

property hj_reserved_space{
    component = mem;
    type = boolean;
};

property hj_use_upstream_ff {
    component = addrmap | mem;
    type = boolean;
};

property hj_use_backward_ff {
    component = addrmap;
    type = boolean;
};

// whether this module uses absolute address to access its internal space
property hj_use_abs_addr {
    component = addrmap | mem;
    type = boolean;
};

// whether to skip the 1st DFF in regslv for internal regfile,
// the property is not permitted to use in internal addrmap, default false
property hj_skip_reg_mux_dff_0{
    component = addrmap;
    type = boolean;
};

// whether to skip the 2nd DFF in regslv for internal regfile,
// the property is not permitted to use in internal addrmap, default true
property hj_skip_reg_mux_dff_1{
    component = addrmap;
    type = boolean;
};

// whether to skip the 1st DFF in regslv for external module,
// the property is not permitted to use in internal addrmap, default false
property hj_skip_ext_mux_dff_0{
    component = addrmap;
    type = boolean;
};

// whether to skip the wnd DFF in regslv for external module,
// the property is not permitted to use in internal addrmap, default true
property hj_skip_ext_mux_dff_1{
    component = addrmap;
    type = boolean;
};

// maximum input number of mux can handle for internal regfile,
// two-level split_mux will be generated if input number exceeds this value, default 128
property hj_reg_mux_size{
    component = addrmap;
    type = longint;
};

// maximum input number of mux can handle for external module,
// two-level split_mux will be generated if input number exceeds this value, default 128
property hj_ext_mux_size{
    component = addrmap;
    type = longint;
};