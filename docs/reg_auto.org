#+title: HJ-micro Register Design Automation (HRDA)
#+author: Neo
#+latex_class: book

#+include: "notes/org/export_header.org"

* Revision History
:PROPERTIES:
:UNNUMBERED: t
:END:

#+ATTR_LATEX: :environment longtable :align |c|c|p{.75\textwidth}|
|------------+----------+------------------------------------|
|       Date | Revision | Description                        |
|------------+----------+------------------------------------|
| 2022-03-22 |      0.1 | Add regmst for deadlock detection. |
|------------+----------+------------------------------------|


* Introduction

#+ATTR_LATEX: :width 0.95\textwidth
#+caption: HJ-micro Regsiter Design Automation Flow \label{fig:reg_auto_flow}
[[file:rdlregs/vp/regs_auto_flow.pdf]]

HJ-micro Register design Automation (HRDA) (as shown in
autoref:fig:reg_auto_flow) is a methdology that automates register
module description and code generation.  The methdology has two input
formats: /Excel spreadsheet/ and /SystemRDL/.  For modules with a few
registers and simple address mapping, Excel spreadsheet is
recommended.  For complex module with fancy mappings, SystemRDL is
more expressive and flexible.


In Excel spreadsheet based flow, HRDA scripts can generate an Excel
spreadsheet file which contains predefined layout for register
descriptions.  Users fill the spreadsheet to finish register module
design.  HRDA scripts then parse the spreadsheet and generate a
equivalent SystemRDL file for rest of the flow. 


After parsing is done, semantic checking is performed on internal data
structure, such as:
1. check address overlap among all registers
2. check fields concatenation overlap which a register word
3. check start address of each memory block is aligned


After semantic check is done, several output files are generated:
1. RTL modules for each generation boundary.
2. HTML document for all registers
3. RAL for all registers
4. C Header for all registers

* InProgress RTL Architecture
SCHEDULED: <2022-02-11 Fri 13:35>
:PROPERTIES:
:ID:       4aa344c3-a359-4267-8661-e01ea5dcb541
:END:
:LOGBOOK:
- State "InProgress" from "TODO"       [2022-03-08 Tue 15:45]
:END:

** Register Network
#+ATTR_LATEX: :width 0.85\textwidth
#+caption: Register Network Architecture \label{fig:reg_network_arch}
[[file:rdlregs/arch-1.pdf]]

Register network implmeneted by HRDA flow is a multi-root hierarchical
network.  A typical network is shown in autoref:fig:reg_network_arch.
Control/Status regsiters are distributed all around the chip modules.
~regmst~ (Register Access Master) is the root of a register hierarchy.
It translates AHB or APB access to register native access interface
([[id:12d881a7-8165-4e18-97f3-c1b8e835573d][reg_native_if]]).  A system can have multiple ~regmst~ to form a large
network and support concurrent register access.

Each module that has registers will be connected into register network
via reg_native_if.  Typically, reg_natvie_if is implmented by follow
components:
1. ~regslv~: a module generated by HRDA scripts that contains all
   registers described in SystemRDL.  ~regslv~ can be chained to form
   a hierarchy.
2. ~regslv2mem~: a module genreated by HRDA scripts that bridges
   reg_natvie_if to memory modules for mapping memory into register
   space.
3. Other ~regslv~ bridge that bridge third party IP register access
   interface to register network.  It is expected to be implmented by
   user, such as:
   - ~regslv~ to APB bridge
   - ~regslv~ to CR Parallel brdige for connecting PHY registers
   - etc.
     


** Register Access Master (regmst)
#+ATTR_LATEX: :width 0.75\textwidth
#+caption: Register Network Architecture \label{fig:regmst_arch}
[[file:rdlregs/arch-2.pdf]]

autoref:fig:regmst_arch shows architecture of ~regmst~.  ~regmst~
bridges SoC access (usually AHB or APB) to reg_native_if.
~dispatch_dec~ (dispatch decoder) decodes the target address and
forwards the access to next stage ~regslv~.  After sending the access
request, ~regmst~ starts a timer.  If timeout is detected in waiting
the response, ~regmst~ reponds to AHB/APB with a configurable fake
data (such as 0xffff_ffff, or 0xdead_beef), and raises an interrupt to
report the timeout event.  The unresponded request information is
logged in local register in ~regmst~.  Software can determine the
problematic module by reading the error log register in ~regmst~.  And
trigger a soft-reset within the hierarchy of ~regmst~.  ~regmst~ will
assert soft-reset reset signal, which is broadcasted to all ~regslv~
(including ~regslv2mem~ and all ~regslv~ brdiges).  The software reset
will reset all FSM and bring back the hierarchy below ~regmst~ to
functional.

#+ATTR_LATEX: :width 0.55\textwidth
#+caption: Register Mster Operation Flow \label{fig:regmst_op}
[[file:rdlregs/vp/regmst_op.pdf]]


~regmst~ doesn't support outstanding request.  So timeout detecting
logic is quite straitforward (autoref:fig:regmst_op) in FSM:
1. ~regmst~ decodes target address to determine the output interface
3. ~regmst~ starts forwarding access to next stage ~regslv~, waits for
   response, and starts a 10ms timer.
   1. If response comes back, ~regmst~ sends response back to SoC,
      reset timer, and transaction is completed.
   2. If timeout occurs during waiting, ~regmst~ logs the transaction,
      finishes the transaction with fake data, and raise interrupt. 



** Register Access Slave (regslv)

#+ATTR_LATEX: :width 0.75\textwidth
#+caption: Register Slave RTL Module Architecture \label{fig:regslv_arch}
[[file:rdlregs/arch-3.pdf]]

The generated module is ~regslv~.  Its general architecture is shown
in autoref:fig:regslv_arch.  Each generation boundary (~addrmap~ in
RDL or a sheet in Excel) have a corresponding ~regslv~ module.  RTL
module name (and Verilog filename) is ~regslv_XXX~, where ~XXX~ is RDL
or Excel filename.

Each ~regslv~ can have its own registers.  It can also forward access
to its downstream ~regslv~, memory instances, or third party IPs.  For
third party IPs, designers will have to implement a bridge to translate
between different access protocol.


*** CDC Considerations
It is obvious that modules in SoC operate at different clocks.
~regslv~ network operates in a slow clock domain (clk_regs, e.g.,
50MHz).  Target module operate in its own clock domain.  CDC are
implemented as below:
1. Use ~value_deliver~ to transfer reg_native_if request to target
   module domain, before register address decoding.
2. Use ~value_deliver~ to transfer register read data from target
   module domain back to ~regslv~ domain.
3. Use ~value_deliver~ to transfer request and response in all
   ~regslv~ bridges, including ~regslv2mem and third party IP brdige. 

   

*** reg_native_if
:PROPERTIES:
:ID:       12d881a7-8165-4e18-97f3-c1b8e835573d
:END:
~regslv~ uses reg_natvie_if for register access.  It also uses
reg_natvie_if to forward register access.  All ~regslv~ bridges should
implement reg_natvie_if.  Signals of reg_natvie_if are listed as
below:

#+begin_src verilog
parameter ADDR_WIDTH = 64;
parameter DATA_WIDTH = 32;

input                  req_vld;
input                  wr_en, rd_en;
input [ADDR_WIDTH-1:0] addr;
input [DATA_WIDTH-1:0] wr_data;
output                 req_rdy;

output                  ack_vld;
output [DATA_WIDTH-1:0] rd_data;
#+end_src

~req_vld~ quarlifies other input signals, when both ~req_vld~ and
~req_rdy~ are asserted, register access is accepted by ~regslv~.
~ack_vld~ quarlifies output signal.  There is no backpressure in
response path, so only ~ack_vld~ is enough. 

Input ~reg_native_if~ is always populated.  Number of forward
~reg_native_if~ is generate according to *external* component
described in RDL.

*** slv_fsm
~slv_fsm~ handles transactions at input reg_native_if.  It also
forwards transaction to output reg_native_if in case the access
falls in range of external component.  

*** full_decoder
~full_decoder~ decodes address and create a ~reg_sel[N-1:0]~ vector.
It is generated by automation tool as a SystemVerilog ~unique case~
statement, as demonstrated below:
#+begin_src verilog
unique case (addr)
  reg_sel = {NUM_OF_REG{1'b0}};
  dummy_reg = 1'b0;

`REG_ADDR_0, `REG_ADDR_1:
  reg_sel[0] = 1'b1;

  // other reg_sel[i] assignment
  // ...
  // ...

  default: dummy_reg = 1'b1;
endcase
#+end_src



*** split_mux
split_mux is a onehot-mux that has parameter to specify /group size/.
When number of input candidcates exceed the group size, a two-level
MUX network is constructed.  DFF is inserted between first level and
second level to improve timing. 

** Register and Field

*field* is the lowest-level structure component, it has software and
hardware access type.  Its structure is shown in autoref:fig:field_struct. 

#+ATTR_LATEX: :width 0.95\textwidth
#+caption: Field RTL structure \label{fig:field_struct}
[[file:rdlregs/vp/field.png]]


~field~ is an existing RTL module, it implements various hardware and
software access types which can be mapped to RDL descriptions.

#+begin_src verilog
module field (clk, rst_n,

              sync_rst,

              ext_async_reset_value,
              ext_sync_reset_value, 
   
              write_protect_en,
              sw_wr, sw_rd, sw_wr_data, 

              hw_pulse, hw_value,

              field_value);

   // Field width
   parameter F_WIDTH       = 4;

   // Number of synchronous reset.  sync_rst input is always
   // populated, so if SRST_CNT=0, sync_rst port width is the minimal
   // value 1 for a legitimate verilog module, and the port is not
   // used.  If SRST_CNT>0, sync_rst port width is declared
   // accordingly for connection.
   parameter SRST_CNT      = 0;
   parameter SRST_WIDTH    = SRST_CNT ? SRST_CNT : 1;

   // Asynchronous/Synchronous reset values.  By default, they are
   // both zero.
   parameter [F_WIDTH-1:0] ARST_VALUE = {F_WIDTH{1'b0}};
   parameter [F_WIDTH-1:0] SRST_VALUE  = ARST_VALUE;

   // Flags to use external reset value.  If asserted,
   // asynchronous/synchronous reset values comes from input ports. 
   parameter USE_EXT_ASYNC_VALUE = 0;
   parameter USE_EXT_SYNC_VALUE  = 0;

   // Software and hardware access type.  
   parameter SW_TYPE       = `SW_RW;
   parameter HW_TYPE       = `HW_RO;

   // Field value update priority, by default software dominates the
   // update.
   parameter WR_PRIORITY   = `SW;



   // Clock and asynchronous active-low reset
   input                      clk, rst_n;

   // Synchronous active-high reset
   input [SRST_WIDTH-1:0]     sync_rst;

   // External asynchronous/synchronous reset value.  If used, they
   // must be stable before assertion of field local reset.
   input [F_WIDTH-1:0]        ext_async_reset_value, 
                              ext_sync_reset_value;

   // Software access interface
   input [F_WIDTH-1:0]        sw_wr_data;
   input                      sw_rd, sw_wr;

   // Write protection enable, which is checked on each software
   // access.  When asserted, software can't modify field value.  In
   // other words, any SW_TYPE is tempoarily changed SW_RO. 
   input                      write_protect_en;

   // Hardware access interface.  Interpretation of this interface is
   // different for different HW_TYPE. 
   input [F_WIDTH-1:0]        hw_value;
   input                      hw_pulse;

   // Field value output.  Software read field value from it, any
   // software/hardware modification occurs at next cycle.
   output [F_WIDTH-1:0]       field_value;

endmodule
#+end_src

All supported access types are listed in ~rdlreg.vh~ 
#+begin_src verilog
// Sowftware types
`define SW_RO         5'h0 // Read only
`define SW_RW         5'h1 // Read write
`define SW_RW1C       5'h2 // Read only, write 1 to clear.
`define SW_RW1S       5'h3 // Read only, write 1 to set.
`define SW_ROC        5'h4 // Read clear
`define SW_W1CO       5'h5 // Read return 0, write 1 to clear, same as SW_RW1C
`define SW_W1SO       5'h6 // Read return 0, write 1 to set, same as SW_RW1S


// Hardware types
// simple access type, build-in support
`define HW_RO         5'h0  // Read-Only
`define HW_WIRED      5'h1  // Hard wired.  register value is
                            // refreshed in realtime by hardware.
                            // hw_pulse is ignored, hw_value is always
                            // loaded to field. 
`define HW_SET        5'h2  // Bitwise set, hw_pulse input is ignored.
`define HW_CLR        5'h3  // Bitwise clear, hw_pulse input is ignored.
`define HW_ANDED      5'h4  // Bitwise AND, hw_pulse input is ignored.
`define HW_ORED       5'h5  // Bitwise OR, hw_pulse input is ignored.
`define HW_XORED      5'h6  // Bitwise XOR, hw_pulse input is ignored.
`define HW_VALUE      5'h7  // Set hw_value into field when hw_pulse
                            // is asserted, usually a pulse
`define HW_SELF_CLR   5'h8  // The asserted bit in field will be
                            // cleared at next cycle, hw_pulse input
                            // is ignored.

// complex access type, supported via other module
`define HW_CNT            5'h9  // Counter mode
`define HW_INT_EN_STATUS  5'hC  // Interrupt 



`define SW 0
`define HW 1

`define XREG_DEBUG 1
#+end_src



Field is concatenated to form register and further mapped into address
space for software's access, as shown in autoref:fig:field_to_reg. 

#+ATTR_LATEX: :width 0.95\textwidth
#+caption: field Concatenation and mapping \label{fig:field_to_reg}
[[file:rdlregs/vp/field_to_reg.png]]


** External Components
When ~regslv~ detects access is for external components, it forwards
it via output ~reg_native_if~.  There several types of external
components:
1. Memory: memory instances in design can be mapped into register spaces. 
2. Third party IP: registers in third party IP should be mapped into SoC. 
3. Other ~regslv~: downstream modules or ~regslv~ bridges can be
   chained to form a large register network. 





* InProgress SystemRDL Coding Guideline
SCHEDULED: <2022-03-10 Thu>
:PROPERTIES:
:ID:       e531f609-09d8-4f0f-b93b-b62ccdab089b
:END:
:LOGBOOK:
- State "InProgress" from              [2022-03-15 Tue 16:23]
:END:

# [[file:~/Documents/zotero/storage/LJXRYRR3/Accellera - 2018 - SystemRDL 2.0 Register Description Language.pdf][-- systemRDL.pdf --]]
SystemRDL ([[cite:&accelleraSystemRDLRegisterDescription2018]]) is a
flexible language for describing register modules.  This section
provides coding guidelines for simplifying register module description.

These coding guidelines specify a subset of SystemRDL syntax and
property to use.  The generation scripts *only* interpret this subset.
Using of other description styles not mentioned in this document is
not supported by the generation scripts.

** General Rules
:PROPERTIES:
:ID:       cf4f00e0-adb6-4c73-9e4a-899d641358bd
:END:
*** Structural Components
SystemRDL has following structural components that map to RTL design
in [[id:4aa344c3-a359-4267-8661-e01ea5dcb541][RTL Architecture]]:
1. ~field~ for describing Field
2. ~reg~ for describing Register
3. ~regfile~ for packing registers together with address allocation
4. ~addrmap~ similar to ~regfile~ on register packing and address
   allocation.  Additionally, it defines a RTL code generation
   boundary.  Each definition of ~addrmap~ with ~gencode~ property set
   will be generated to an ~regslv~ module.
5. ~signal~ for declaring signals used in components defintions.


#+caption:  Syntax for defining Component \label{fig:def_comp}
#+ATTR_LATEX: :width 0.85\textwidth
[[file:/home/xinmeng/Documents/org-download-images/20220316_163553_screenshot.png]]


autoref:fig:def_comp shows the syntax for defining components.
Components can be defined in any order, as long as each component is
defined before it is instantiated.  All structural components (and
signals) need to be instantiated before being generated.

Here is an example for register definition, where register ~myReg~ is
a /definitive definition/, and field ~data~ is an /anonymous
definition/.

#+begin_src systemrdl
reg myReg #(longint unsigned SIZE = 32, boolean SHARED = true) {
  regwidth = SIZE;
  shared = SHARED;
  field {} data[SIZE – 1];
  };
#+end_src


Component definitions can have parameters.  Parameter can be
overridden when component is being instantiated
([[cite:&accelleraSystemRDLRegisterDescription2018]] section 5.1.1.1).
Here is an example:

#+begin_src systemrdl
addrmap myAmap {
    myReg reg32;
    myReg reg32_arr[8];
    myReg #(.SIZE(16)) reg16;
    myReg #(.SIZE(8), .SHARED(false)) reg8;
};
#+end_src

*** Property
Structural components have various *property* to define their
behaviors.  Each property is associated with at least on data type
(such integer, boolean, string, etc).  In addition to build-in
property defined in SystemRDL, user can add *User-defined* properties.

Property can be assigned at definition time:
#+begin_src systemrdl
field {} outer_field ;
reg {
  default name = "default name";
  field {} f1; // assumes the name "default name" from above
  field { name = "new name";} f2; // name assignment overrides "default name"
  outer_field f3 ; // name is undefined, since outer_field is not defined in the
                   // scope of the default name
} some_reg;  
#+end_src


Property can also be dynamically assigned:
#+begin_src systemrdl
reg {
  field {} f1;
  f1->name = "New name for Field 1";
  } some_reg[8];

some_reg->name = "This value is applied to all elements in the array";
some_reg[3]->name = "Only applied to the 4th item in the array of 8";
#+end_src

*** Instantiating Components
#+caption: Syntax for Instantiating Components \label{fig:inst_comp}
#+ATTR_LATEX: :width 0.85\textwidth
[[file:/home/xinmeng/Documents/org-download-images/20220316_162334_screenshot.png]]


autoref:fig:inst_comp is extracted from
[[cite:&accelleraSystemRDLRegisterDescription2018]] section 5.1.2, which
describes the syntax for instantiating component.  Here are some
examples:

#+begin_src systemrdl
// The following code fragment shows a simple scalar field component instantiation.
field {} myField; // single bit field instance named “myField”

// The following code fragment shows a simple array field component instantiation.
field {} myField[8]; // 8 bit field instance named “myField”
#+end_src


*** Instance address allocation: alignment, addressing mode, addr_alloc
The offset of an instance within an object is always relative to its
parent object.  If an instance is not explicitly assigned an address
allocation operator (see [[id:e7170ec2-c26e-434f-b022-5397f4d331b0][Address Allocation Operator]]), the compiler
assigns the address according to the *alignment* and /addressing
mode/.  The address of an instance from the top level ~addrmap~ is
calculated by adding the instance offset and the offset of all its
parent objects.


**** alignment
The *alignment* property defines the byte value of which the
container's instance addresses shall be a multiple. This property can
be set for ~addrmaps~ and ~regfiles~ , and its value shall be a power
of two ($2^N$).  Its value is inherited by all of the container's
non-addrmap children.  By default, instantiated objects shall be
aligned to a multiple of their width (e.g., the address of a 64-bit
register is aligned to the next 8-byte boundary).

**** Addressing Mode
*addressing* property can only be used in ~addrmap~ component.  There
are three addressing modes: ~compact~, ~realign~ (the default), and
~fullalign~.

~compact~ Specifies the components are packed tightly together while
still being aligned to the ~accesswidth~ parameter:

#+begin_src systemrdl
addrmap some_map {
    default accesswidth=32;
    addressing=compact;
    reg { field {} a; } a; // Address 0x0 - 0x3: 4 bytes
    reg { regwidth=64; field {} a; } b; // Address 0x4 - 0x7: lower 32-bit,
                                        // Address 0x8 - 0xB: higher 32-bit
                                        // starting address 0x4 tightly follows previous
                                        // reg "a"
    reg { field {} a; } c[20]; // Address 0xC  - 0xF:  Element 0
                               // Address 0x10 - 0x13: Element 1
                               // Address 0x14 - 0x17: Element 2
};


addrmap some_map {
    default accesswidth=64;
    addressing=compact;
    reg { field {} a; } a; // Address 0x0 - 0x3: 4 bytes
    reg { regwidth=64; field {} a; } b; // Address 0x8 - 0xB: 
    reg { field {} a; } c[20]; // Address 0x10 - Element 0
                               // Address 0x14 - Element 1
                               // Address 0x18 - Element 2
                               // starting address is 0x10, align to 64-bit, 4 bytes in 0xC-0xF is skipped
};
#+end_src

~regalign~ Specifies the components are packed so each component's
start address is a multiple of its size (in bytes).  Array elements
are aligned according to the individual element's size (this results
in no gaps between the array elements).  This generally results in
simpler address decode logic.

#+begin_src systemrdl
addrmap some_map {
  default accesswidth = 32;  
  addressing = regalign;
  reg { field {} a; } a; // Address 0x0
  reg { regwidth=64; field {} a; } b; // Address 0x8-0xF, align to 64-bit
  reg { field {} a; } c[20]; // Address 0x10
                             // Address 0x14 - Element 1
                             // Address 0x18 - Element 2
};  
#+end_src


~fullalign~ The assigning of addresses is similar ~regalign~, except
for arrays.  The alignment value for the first element in an array is
the size in bytes of the *whole array* (i.e., the size of an array
element multiplied by the number of elements), *rounded up to nearest
power of two*.  The second and subsequent elements are aligned
according to their individual size (so there are no gaps between the
array elements).

#+begin_src systemrdl
addrmap some_map {
  default accesswidth = 32;  
  addressing = fullalign;
  reg { field {} a; } a; // Address 0
  reg { regwidth=64; field {} a; } b; // Address 8
  reg { field {} a; } c[20]; // Address 0x80 - Element 0
                             // Address 0x84 - Element 1
                             // Address 0x88 - Element 2
                             // starting address align to 4*20=80Byte, 
};
#+end_src


**** Address Allocation Operator
:PROPERTIES:
:ID:       e7170ec2-c26e-434f-b022-5397f4d331b0
:END:

When instantiating ~reg~, ~regfile~, ~mem~, or ~addrmap~, the address
may be assigned using one of following address allocation operators

1. ~@~: It specifies the address for the instance.
   #+begin_src systemrdl
addrmap top {
  regfile example{
    reg some_reg {
      field {} a;
      };
    
    some_reg a @0x0;
    some_reg b @0x4;

    // Implies address of 8
    // Address 0xC is not implemented or specified
    some_reg c;         

    some_reg d @0x10;
    };
  };
   #+end_src

2. ~+=~: It specifies the address stride when instantiaing an array of
   components (controls the spacing of the components).  The address
   stride is relative to the previous instane's address.  It is only
   used for arrayed ~addrmap~, ~regfile~, ~reg~, or ~mem~.
   #+begin_src systemrdl
addrmap top {
  regfile example {
    reg some_reg { field {} a; };

    some_reg a[10]; // So these will consume 40 bytes
                    // Address 0,4,8,C....
    
    some_reg b[10] @0x100 += 0x10; // These consume 160-12 bytes of space
                                   // Address 0x100 to 0x103, 0x110 to 0x113,....
    };
  };
   #+end_src

3. ~%=~: It specifies the aligment of address when instantiaing a
   component (controls the aligment of the components).  The initial
   address alignment is relative to the previous instance's address.
   The ~@~ and ~%=~ operators are mutually exclusive per instance.
   #+begin_src systemrdl
addrmap top {
  regfile example {
    reg some_reg { field {} a; };

    some_reg a[10]; // So these will consume 40 bytes
                    // Address 0,4,8,C....
    
    some_reg b[10] @0x100 += 0x10; // These consume 160-12 bytes of space
                                   // Address 0x100 to 0x103, 0x110 to 0x113,....
    
    some_reg c %=0x80; // This means ((address % 0x80) == 0))
                       // So this would imply an address of 0x200 since
                       // that is the first address satisfying address>=0x194
                       // and ((address % 0x80) == 0)
  };
};
   #+end_src

** Signal

** Field Description

*** Naming Convention
Each RDL *field* instance will be generated to an Verilog ~field~
module instance.  In generated RTL, stem name of field is
~<reg_inst_name>__<field_inst_name>~.  Other signals belong to the
field are named by prefixing/suffixing elements.  e.g., Register
instance name is ~ring_cfg~, Field instance name is ~rd_ptr~:

1. ~field~ instance name is ~x__<stem>~ (prefixed with ~x__~):
   ~x__ring_cfg__rd_ptr~
2. output port name for current Field value is ~<stem>__curr_value~:
   ~ring_cfg__rd_ptr__curr_value~
3. input port for update its value from hardware is
   ~<stem>__next_value~: ~ring_cfg__rd_ptr__next_value~
4. input port for quarlifying update is ~<stem>__pulse~:
   ~ring_cfg__rd_ptr__pulse~


*** Description Guideline
SystemRDL defines several properties for describing Field, however,
only a subset of them are interpreted by the scripts.  Only properties
documented in this section are allowed for Field description, others
are prohibited to use.

#+ATTR_LATEX: :environment longtable  :align |l|p{.55\textwidth}|c|c|c|
#+caption: Field Properties Supported in scripts  \label{tab:field_prop} 
|-------------------+-----------------------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|
| Property          | Notes                                                                                                                             | Type               | Default | Dynamic |
|                   | <40>                                                                                                                              |                    |         |         |
|-------------------+-----------------------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|
| *fieldwidth*      | Width of Field.                                                                                                                   | /longint unsighed/ | 1       | No      |
| *reset*           | Reset value of Field.                                                                                                             | /bit/              | 0       | Yes     |
| *resetsignal*     | Reference to signal used as *Asynchornous reset* of the Field.                                                                    | /reference/        |         | Yes     |
| *hj_syncresetsignal* | Reference to signal used as *Synchronous Reset* of the Field.                                                                     | /reference/        |         | Yes     |
| *name*            | Specifies a more descriptive name (for documentation purposes).                                                                   | /string/           | ""      | Yes     |
| *desc*            | Describes the component's purpose.  MarkDown syntax is allowed                                                                    | /string/           | ""      | Yes     |
| *sw*              | Software access type, one of ~rw~, ~r~, ~w~, ~rw1~, ~w1~, or ~na~.                                                                | /access type/      | ~rw~    | Yes     |
| *onread*          | Software read side effect, one of ~rclr~, ~rset~, or ~na~.                                                                        | /onreadtype/       | ~na~    | Yes     |
| *onwrite*         | Software write side effect, one of ~woset~, ~woclr~, ~wot~, ~wzs~, ~wzc~, ~wzt~, or ~na~.                                         | /onwritetype/      | ~na~    | Yes     |
| *swmod*           | Populate an output signal which is asserted when field is modified by software (written or read with a set or clear side effect). | /boolean/          | false   | Yes     |
| *swacc*           | Populate an output signal which is asserted when field is read.                                                                   | /boolean/          | false   | Yes     |
| *singlepulse*     | Populate an output signal which is asserted for one cycle when field is written 1.                                                | /boolean/          | false   | Yes     |
| *hw*              | Hardware access type, one of ~rw~, or ~r~                                                                                         | /access type/      | ~r~     | No      |
| *hwclr*           | Hardware clear.  Field is cleared upon assertion on hardware signal in bitwise mode.                                              | /boolean/          | false   | Yes     |
| *hwset*           | Hardware set.  Field is set upon assertion on hardware signal in bitwise mode.                                                    | /boolean/          | false   | Yes     |
| *precedence*      | One of ~hw~ or ~sw~, controls whether precedence is granted to hardware (~hw~) or software (~sw~) when contention occurs.         | /precedencetype/   | ~sw~    | Yes     |
|-------------------+-----------------------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|


*resetsignal* specifies signal used as *Asynchronous reset* for
the Field.  By default, ~rst_n~ is used as asynchronous reset signal.
When set to a reference of signal, an input port is populated for the
signal and the field's asynchronous reset will be connected to the
signal.


*hj_syncresetsignal* is a /User-defined/ property that specifies signal
(or multiple signals) used as *Synchronous Reset* for the Field.  By
default, a Field doesn't have Synchronous reset.  User can set
*hj_syncresetsignal* property more than once to specify multiple
synchronous reset signals.  Each synchronous reset signal *must* be
active high and one clock cycle wide.  Reset value of synchronous
reset is the same as that of asynchronous reset.


When *singlepulse* is ~true~, *onwrite* property is ignored.  

Current value of Field (~<stem>__curr_value~) is always output to user
logic.  If *hw* is ~rw~, two more inputs are populated
(~<stem>__next_value~ and ~<stem>__pulse~) for updating field value
from user logic.  If value from hardware is expected to be continously
updated into Field, user should tie ~<stem>__pulse~ to ~1'b1~.  If
either *hwclr* or *hwset* is ~true~ (they are mutually exclusive),
~field~ module use ~<stem>__next_value~ in bitwide mode and ignores
~<stem>__pulse~.  Each pulse in ~<stem>__next_value~ will clear or set
corresponding bit on Field. 


*** Examples
#+begin_src systemrdl
field {sw=rw; hw=r;} f1[15:0] = 1234;

field f2_t {sw=rw; hw=r;};

f2_t f2[16:16] = 0;
f2_t f3[17:17] = 0;

field {
    sw=rw; hw=r;
    hdl_path_slice = '{"f4"};
    hdl_path_gate_slice = '{"f4_31_gate", "f4_30_gate"};
} f4[31:30] = 0;
field {
    sw=rw; hw=r;
    hdl_path_slice = '{"f5_29", "f5_28"};
    hdl_path_gate_slice = '{"f5_gate"};
} f5[29:28] = 0;

#+end_src

** Regsiter Description

*** Naming Convention
Each Register is a concatenation of Fields.  No RTL module is
implemented for Register.  Instead, an ~always_comb~ block is used to
concatenate Fields ~curr_value~ as below:

#+begin_src verilog
// ring_cfg
always_comb begin
   ring_cfg[31:0] = 32'd0;
   ring_cfg[31] = ring_cfg__ring_en__curr_value;
   ring_cfg[7:4] = ring_cfg__ring_size__curr_value[3:0];
end
#+end_src


All Fields in a Register share same register ~rd_en~, ~wr_en~, and
~wr_data~.  Scripts will connect the correct signal from address
decoder to Field instances. 

*** Description Guideline

Register definitions are all considered to be *internal*.  *external*
is only applied on ~regfile~ instances.

*alias* property ([[cite:&accelleraSystemRDLRegisterDescription2018]]
 section 10.5) is supported on regsiter instances within regfile.

An /alias register/ is a register that appears in multiple locations
of the same address map.  It is physically implemented as a single
register such that a modification of the register at one address
location appears at all the locations within the address map.  The
accessibility of this register may be different in each location of
the address block.

Alias registers are allocated addresses like physical registers and
are decoded like physical registers, but they perform these operations
on a previously instantiated register (called the primary
register).  Since alias registers are not physical, hardware access and
other hardware operation properties are not used.  Software access
properties for the alias register can be different from the primary
register.  For example,

#+begin_src systemrdl
reg some_intr_r { field { level intr; hw=w; sw=r; woclr; } some_event; };
addrmap foo {
  some_intr event1;
  
  // Create an alias for the DV team to use and modify its properties
  // so that DV can force interrupt events and allow more rigorous structural
  // testing of the interrupt.
  alias event1 some_intr event1_for_dv;
  event1_for_dv.some_event->woclr = false;
  event1_for_dv.some_event->woset = true;
};
#+end_src


*shared* propery, on the other hand, allows same physical register to
be mapped in several different address space. 


#+ATTR_LATEX: :environment longtable  :align |l|p{.55\textwidth}|c|c|c|
#+caption: Register Properties Supported in scripts  \label{tab:reg_prop} 
|-------------+---------------------------------------------------------------+--------------------+---------+---------|
| Property    | Notes                                                         | Type               | Default | Dynamic |
|             | <40>                                                          |                    |         |         |
|-------------+---------------------------------------------------------------+--------------------+---------+---------|
| *regwidth*  | Width of Register.                                            | /longint unsighed/ | 32      | No      |
| *shared*    | Defines a register as being shared in different address maps. | /boolean/          | false   | No      |
|-------------+---------------------------------------------------------------+--------------------+---------+---------|


*** Examples

** regfile

*** Description Guideline
A ~regfile~ is as a logical grouping of one or more registers and
~regfile~ instances.  It packs registers together and provides address
allocation support, which is useful for introducing an address gap
between registers.  The only difference between the ~regfile~ and the
address map (~addrmap~) is an ~addrmap~ defines an RTL implementation
boundary where the ~regfile~ does not.  Since ~addrmaps~ define a
implementation block boundary, there are some specific properties that
are only specified for address maps and not specified for ~regfiles~.

When ~regfile~ is instantiated within another ~regfile~, scripts
consider inner ~regfile~ instances are flattened and concatenated to
form a larger ~regfile~.  So "~regfile~ nesting" is just a technique
to organize register descriptions.  No *internal* or *external* is
considered.

Standard SystemRDL allows *external* to be applied on ~regfile~
instances, but HRDA scripts ignores *external* modifier on ~regfile~
instance.  ~regfile~ instance is always considered as packer of
registers.  *external* only applies on ~addrmap~ instances. 


#+ATTR_LATEX: :environment longtable  :align |l|p{.55\textwidth}|c|c|c|
#+caption: regfile Properties Supported in scripts  \label{tab:regfile_prop} 
|-------------+-------------------------------------------------------------------------------------+--------------------+---------+---------|
| Property    | Notes                                                                               | Type               | Default | Dynamic |
|             | <40>                                                                                |                    |         |         |
|-------------+-------------------------------------------------------------------------------------+--------------------+---------+---------|
| *alignment* | Specifies alignment of all instantiated components in the associated register file. | /longint unsighed/ |         | No      |
|-------------+-------------------------------------------------------------------------------------+--------------------+---------+---------|


*** Example
#+begin_src systemrdl
regfile myregfile #(.A (32)) {
  alignment = 32;  
  reg {} xx;
}  
#+end_src


** InProgress Memory
SCHEDULED: <2022-03-08 Tue>
:LOGBOOK:
- State "InProgress" from              [2022-03-18 Fri 14:54] \\
  Need to add snapshot register for atomic memory access
:END:

*** Descriptions Guideline
Memory instances in ~addrmap~ are always *external*.  When mapping
memory into register space, the generated ~reg_slv~ module forwards
access that falls in memory address region to memory access interface.
Each mapped memory has a dedicated access data path.

Memory definition accepts properties listed in autoref:tab:mem_prop. 

#+ATTR_LATEX: :environment longtable  :align |l|p{.55\textwidth}|c|c|c|
#+caption: Memory Properties Supported in scripts  \label{tab:mem_prop} 
|--------------+---------------------------------------------------+---------------------+---------+---------|
| Property     | Notes                                             | Type                | Default | Dynamic |
|              | <40>                                              |                     |         |         |
|--------------+---------------------------------------------------+---------------------+---------+---------|
| *mementries* | The number of memory entries, a.k.a memory depth. | /longint unsighed/  |         | No      |
| *memwidth*   | The memory entry bit width, a.k.a memory width.   | /logical unsighed/  |         | No      |
| *sw*         | Programmer's ability to read/write a memory.      | /access type/       | ~rw~    | Yes     |
|--------------+---------------------------------------------------+---------------------+---------+---------|


If *memwidth* is larger than *accesswidth*, each memory entry occupies
$N$ address slots, where $N$ should be power of 2 ($2^i$) to simplify
decode logic.  Generated module will implement a snapshot register to
atomically read/write memory entry. 


*** Example


** InProgress Address Map
SCHEDULED: <2022-03-08 Tue>
:PROPERTIES:
:ID:       2eb7b36d-e5b9-4b41-aca2-cebf0ce8d384
:END:
:LOGBOOK:
- State "InProgress" from              [2022-03-18 Fri 18:55]
:END:

*** Description Guideline
An address map component (~addrmap~) contains registers, register
files, memories, and/or other address maps and assigns address to each
instance of component.  ~addrmap~ defines the boundaries of an RTL
implementation.  Each component might have already assigned address
offset to its contents, ~addrmap~ further adds base address to them.
After the outter most ~addrmap~ finishes assigning base address, absolute
address allocation is settled.

HRDA scripts processes each ~addrmap~ definition as below:
1. ~memory~ instances are always considered *external*.  There will be
   dedicated ~reg_native_if~ populated for each memory instance.
2. ~reg~, ~regfile~ are generated according to the definition.  Their
   contents address are allocated by the enclosing ~addrmap~.
3. ~addrmap~ instances are handled in different ways depending on
   value of ~hj_genrtl~, ~hj_flatten_content~ properties in ~addrmap~
   definition, according to autoref:tab:addrmap_handle




#+ATTR_LATEX: :environment longtable  :align |l|l|p{.35\textwidth}|p{.25\textwidth}|
#+caption: addrmap instance handling  \label{tab:addrmap_handle}
|-----------+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|
| hj_gentrl | hj_flatten_addrmap | handling behavior                                                                                                                          | Usage                                                                    |
|           |                    | <40>                                                                                                                                       |                                                                          |
|-----------+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|
| false     | false              | Populate a dedicated ~reg_native_if~ for the ~addrmap~ instance.  No ~regslv~ RTL module is generated for the ~addrmap~ definition.        | 3rd party IP register description                                        |
| false     | true               | All contents in the ~addrmap~ is flattened in current scope, just like ~regfile~ does.  No ~regslv~ RTL module is generated for ~addrmap~. | Use ~shared~ property to map same register into different address spaces |
| true      | /don't care/       | Populate a dedicated ~reg_natvie_if~ for the ~addrmap~ instances.  And generate ~regslv~ RTL module for the ~addrmap~.                     | Hierarchical ~regslv~ chaining                                           |
|-----------+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|


All HRDA suppored properties for ~addrmap~ is listed in autoref:tab:addrmap_prop. 

#+ATTR_LATEX: :environment longtable  :align |l|p{.55\textwidth}|c|c|c|
#+caption: Address Map Properties Supported in HRDA scripts  \label{tab:addrmap_prop} 
|----------------+------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|
| Property       | Notes                                                                                                            | Type               | Default | Dynamic |
|                | <40>                                                                                                             |                    |         |         |
|----------------+------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|
| *alignment*    | Specifies alignment of all instantiated components in the address map.                                           | /longint unsighed/ |         | No      |
| *addressing*   | Controls how addresses are computed in an address map.                                                           | /addressingtype/   |         | No      |
| *rsvdset*      | The read value of all fields not explicitly defined is set to 1 if rsvdset is ~true~; otherwise, it is set to 0. | /boolean/          | true    | No      |
|----------------+------------------------------------------------------------------------------------------------------------------+--------------------+---------+---------|


*** Example

#+begin_src systemrdl
addrmap some_bridge { // Define a Bridge Device
  desc="overlapping address maps with both shared register space and orthogonal register space";
  reg status {// Define at least 1 register for the bridge
    // Shared property tells compiler this register
    // will be shared by multiple addrmaps
    shared;   

    field {
      hw=rw;
      sw=r;
      } stat1 = 1'b0;
    };


  reg some_axi_reg {
    field {
      desc="credits on the AXI interface";
      } credits[4] = 4'h7;   // End of field: {}

    };  // End of Reg: some_axi_reg

  
  reg some_ahb_reg {
    field {
      desc="credits on the AHB Interface";
      } credits[8] = 8'b00000011 ;
    };
  
  addrmap {
    littleendian;

    some_ahb_reg ahb_credits; // Implies addr = 0
    status ahb_stat @0x20;    // explicitly at address=20
    ahb_stat.stat1->desc = "bar"; // Overload the registers property in this instance
    } ahb;
  
  addrmap { // Define the Map for the AXI Side of the bridge
    bigendian; // This map is big endian
    some_axi_reg axi_credits;   // Implies addr = 0
    status axi_stat @0x40;      // explicitly at address=40
    axi_stat.stat1->desc = "foo"; // Overload the registers property in this instance
    } axi;
}; // Ends addrmap bridge

#+end_src

** User-defined Property

*** hj_syncresetsignal
Assigning ~signal~ instance to this property will populate an extra
input to the component.  That input will be used as synchornous reset
signal.  If this property is assigned in a ~field~ definition, the
input is added for the ~field~ instance.  If this property is assigned
in a ~reg~, ~regfile~, or ~addrmap~, all containing field instances
will have the input as synchornous reset.
#+begin_src systemrdl
property hj_syncresetsignal {
  component = field|reg|regfile|addrmap;
  type = string;
}
#+end_src

*** hj_genrtl
Refer to autoref:tab:addrmap_handle for detail. 
#+begin_src systemrdl
property hj_genrtl {
  component = addrmap;
  type = boolean;
  default = true;  
}
#+end_src

*** hj_flatten_addrmap
Refer to autoref:tab:addrmap_handle for detail. 
#+begin_src systemrdl
property hj_flatten_addrmap {
  component = addrmap;
  type = boolean;
  default = false;  
}

#+end_src

* InProgress Excel Format
   :LOGBOOK:
   - State "InProgress" from              [2022-03-15 Tue 16:23]
   :END:
* TODO Tool Usage
SCHEDULED: <2022-03-12 Sat>

* Bibliography
bibliographystyle:plain
[[bibliography:/home/xinmeng/texmf/bibtex/bib/zotero.bib]]


