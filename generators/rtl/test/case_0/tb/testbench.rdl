addrmap test_1 {
	hj_genrtl = true;

	signal {
		name = "srst_1";
		activehigh;
		sync;
	} srst_1;

	signal {
		name = "srst_2";
		activehigh;
		sync;
	} srst_2;

	// test sw=rw, all onread/onwrite types
	reg REG1_def{
		regwidth = 32;

		field {
			sw = rw;
		} FIELD_0[29:28] = 0x0;

		field {
			sw = rw;
			onread = rclr;
		} FIELD_1[27:26] = 0x0;

		field {
			sw = rw;
			onread = rset;
		} FIELD_2[25:24] = 0x0;

		field {
			sw = rw;
			onwrite = woclr;
		} FIELD_3[23:22] = 0x0;

		field {
			sw = rw;
			onwrite = woset;
		} FIELD_4[21:20] = 0x0;

		field {
			sw = rw;
			onwrite = wot;
		} FIELD_5[19:18] = 0x0;

		field {
			sw = rw;
			onwrite = wzc;
		} FIELD_6[17:16] = 0x0;

		field {
			sw = rw;
			onwrite = wzs;
		} FIELD_7[15:14] = 0x0;

		field {
			sw = rw;
			onwrite = wzt;
		} FIELD_8[13:12] = 0x0;
	} REG1_SW_RW @0x0;

	alias REG1_SW_RW REG1_def REG1_SW_R_W_alias @0X100;
	// test sw=r, all onread types
	REG1_SW_R_W_alias.FIELD_0 -> sw = r;
	REG1_SW_R_W_alias.FIELD_1 -> sw = r;
	REG1_SW_R_W_alias.FIELD_2 -> sw = r;
	// test sw=w, all onwrite types
	REG1_SW_R_W_alias.FIELD_3 -> sw = w;
	REG1_SW_R_W_alias.FIELD_4 -> sw = w;
	REG1_SW_R_W_alias.FIELD_5 -> sw = w;
	REG1_SW_R_W_alias.FIELD_6 -> sw = w;
	REG1_SW_R_W_alias.FIELD_7 -> sw = w;
	REG1_SW_R_W_alias.FIELD_8 -> sw = w;

	// test sw=w, all onwrite types
	reg REG2_def{
		regwidth = 32;

		field {
			sw = w;
		} FIELD_0[31:30] = 0x0;

		field {
			sw = w;
			onwrite = woclr;
		} FIELD_1[29:28] = 0x0;

		field {
			sw = w;
			onwrite = woset;
		} FIELD_2[27:26] = 0x0;

		field {
			sw = w;
			onwrite = wot;
		} FIELD_3[25:24] = 0x0;

		field {
			sw = w;
			onwrite = wzc;
		} FIELD_4[23:22] = 0x0;

		field {
			sw = w;
			onwrite = wzs;
		} FIELD_5[21:20] = 0x0;

		field {
			sw = w;
			onwrite = wzt;
		} FIELD_6[19:18] = 0x0;
	} REG2_SW_W @0x4;

	// test synchronous reset signal
	alias REG2_SW_W REG2_def REG2_SRST_alias @0X104;
	REG2_SRST_alias.FIELD_1 -> hj_syncresetsignal = "srst_1";
	REG2_SRST_alias.FIELD_2 -> hj_syncresetsignal = "srst_2";

	// test hardware access propeties, hwclr, hwset
	reg REG3_def{
		regwidth = 32;

		field {
			hw = rw;
		} FIELD_0[31:30] = 0x0;

		field {
			hw = r;
			onwrite = woclr;
		} FIELD_1[29:28] = 0x0;

		field {
			hwclr;
		} FIELD_2[27:26] = 0x0;

		field {
			hwset;
		} FIELD_3[25:24] = 0x0;
	} REG3_HW @0x8;

	// test hardware access propeties, hwclr, hwset
	reg REG4_def{
		regwidth = 32;

		field {
			sw = rw;
			hw = rw;
			precedence = sw;
		} FIELD_0[31:30] = 0x0;

		field {
			sw = rw;
			hw = rw;
			precedence = hw;
		} FIELD_1[29:28] = 0x0;
	} REG4_PRECEDENCE @0xc;

	// test hardware access propeties, hwclr, hwset
	reg REG5_def{
		regwidth = 32;

		field {
			singlepulse;
		} FIELD_0[31:31] = 0x0;
	} REG5_SINGLEPULSE @0x10;

	// test swacc, swmod
	reg REG6_def{
		regwidth = 32;

		field {
			swacc;
			swmod;
		} FIELD_0[31:30] = 0x0;
	} REG6_SW_ACC_MOD @0x14;
};

// test shared property
reg shared_tem{
	shared;
	regwidth = 32;

	field {
		sw = rw;
	} FIELD_0[31:0] = 0x0;
};

addrmap test_2 {
	hj_genrtl = false;

	// test reset values
	shared_tem shared_2;
	shared_2.FIELD_0 -> reset = 0XFFFFFFFF;
};

addrmap test_3 {
	hj_genrtl = false;
	// test reset values
	shared_tem shared_3;
};

// test external memories
mem ext_mem_def {
    mementries = 64;
    memwidth = 32;
};

addrmap reg_top {
	addrmap {
		hj_genrtl = true;

		// implement downstream regslv
		test_1 test_11;
		// implement internal registers
		test_2 test_12;
		test_3 test_13;
		// implement external memory
		external ext_mem_def ext_mem_11;
	} reg_block_1;

	addrmap {
		hj_genrtl = true;
		// implement internal registers
		test_1 test_21;
		test_21 -> hj_genrtl = false;
		test_2 test_22;
		test_3 test_23;
		// implement external memories
		external ext_mem_def ext_mem_21, ext_mem_22, ext_mem_23;
	} reg_block_2;

	external ext_mem_def ext_mem_in_top;
};
