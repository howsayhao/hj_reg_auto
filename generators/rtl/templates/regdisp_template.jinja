module {{get_rtl_name(disp_node)}} (
    clk,
    rst_n,
    // upstream reg_native_if
    {#
    {% set parent_name = get_inst_name(disp_node.parent) %}
    {{parent_name}}__req_vld,
    {{parent_name}}__ack_vld,
    {{parent_name}}__addr,
    {{parent_name}}__wr_en,
    {{parent_name}}__rd_en,
    {{parent_name}}__wr_data,
    {{parent_name}}__rd_data,
    #}
    upstream__req_vld,
    upstream__ack_vld,
    upstream__addr,
    upstream__wr_en,
    upstream__rd_en,
    upstream__wr_data,
    upstream__rd_data,
    // downstream reg_native_if
    {#
    {% for child in disp_node.children(unroll=True, skip_not_present=False) %}
    {% set child_name = get_inst_name(child) %}
    {{child_name}}__req_vld,
    {{child_name}}__ack_vld,
    {{child_name}}__addr,
    {{child_name}}__wr_en,
    {{child_name}}__rd_en,
    {{child_name}}__wr_data,
    {{child_name}}__rd_data,
    {% endfor %}
    #}
    downstream__req_vld,
    downstream__ack_vld,
    downstream__addr,
    downstream__wr_en,
    downstream__rd_en,
    downstream__wr_data,
    downstream__rd_data,
    // soft reset signals in and out
    soft_rst_i,
    soft_rst_o
);

    parameter   ADDR_WIDTH                              = {{addr_width}};
    parameter   DATA_WIDTH                              = {{data_width}};
    parameter   FORWARD_NUM                             = {{get_forward_num(disp_node)}};
    parameter   [0:FORWARD_NUM-1]   INSERT_FORWARD_DFF  = {{"{" ~ use_forward_ff(disp_node)|join(", ") ~ "}"}};
    parameter   INSERT_BACKWARD_DFF                     = {{use_backward_ff(disp_node)}};

    input   logic   clk, rst_n;

    input   logic                                       upstream__req_vld;
    output  logic                                       upstream__ack_vld;
    input   logic   [ADDR_WIDTH-1:0]                    upstream__addr;
    input   logic                                       upstream__wr_en;
    input   logic                                       upstream__rd_en;
    input   logic   [DATA_WIDTH-1:0]                    upstream__wr_data;
    output  logic   [DATA_WIDTH-1:0]                    upstream__rd_data;

    output  logic   [FORWARD_NUM-1:0]                   downstream__req_vld;
    input   logic   [FORWARD_NUM-1:0]                   downstream__ack_vld;
    output  logic   [FORWARD_NUM-1:0] [ADDR_WIDTH-1:0]  downstream__addr;
    output  logic   [FORWARD_NUM-1:0]                   downstream__wr_en;
    output  logic   [FORWARD_NUM-1:0]                   downstream__rd_en;
    output  logic   [FORWARD_NUM-1:0] [DATA_WIDTH-1:0]  downstream__wr_data;
    input   logic   [FORWARD_NUM-1:0] [DATA_WIDTH-1:0]  downstream__rd_data;

    input   logic                                       soft_rst_i;
    output  logic                                       soft_rst_o;

    logic   [FORWARD_NUM-1:0]                           downstream__req_vld_conv;
    logic   [FORWARD_NUM-1:0] [ADDR_WIDTH-1:0]          downstream__addr_conv;
    logic   [FORWARD_NUM-1:0]                           downstream__wr_en_conv;
    logic   [FORWARD_NUM-1:0]                           downstream__rd_en_conv;
    logic   [FORWARD_NUM-1:0] [DATA_WIDTH-1:0]          downstream__wr_data_conv;

    logic   [FORWARD_NUM-1:0]                           downstream__req_vld_imux;
    logic   [FORWARD_NUM-1:0] [ADDR_WIDTH-1:0]          downstream__addr_imux;
    logic   [FORWARD_NUM-1:0]                           downstream__wr_en_imux;
    logic   [FORWARD_NUM-1:0]                           downstream__rd_en_imux;
    logic   [FORWARD_NUM-1:0] [DATA_WIDTH-1:0]          downstream__wr_data_imux;

    logic                                               upstream__ack_vld_mux;
    logic   [DATA_WIDTH-1:0]                            upstream__rd_data_mux;
    logic   [FORWARD_NUM-1:0]                           dec_if_sel;
    logic                                               dec_dummy_reg_sel;

    /**************************************************************************
    ** forward datapath
    **************************************************************************/

    assign  soft_rst_o  = soft_rst_i;

    // decode upstream absolute address
    always_comb begin
        dec_if_sel          = {FORWARD_NUM{1'b0}};
        dec_dummy_reg_sel   = 1'b0;
        unique casez (upstream__addr[{{dec_addr_bit()|join(":")}}])
        {%- for child in disp_node.children(unroll=True, skip_not_present=False) %}
            {{get_comp_addr(child)|join(",")|indent}}: dec_if_sel[{{loop.index0}}] = 1'b1;
        {%- endfor %}
            default: dec_dummy_reg_sel  = 1'b1;
        endcase
    end

    // forward inverse multiplexor for req_vld, addr, wr_en, rd_en, wr_data
    always_comb begin
        for (integer i = 0; i < FORWARD_NUM; i = i + 1) begin
            downstream__req_vld_imux[i]     = 1'b0;
            downstream__addr_imux[i]        = {ADDR_WIDTH{1'b0}};
            downstream__wr_en_imux[i]       = 1'b0;
            downstream__rd_en_imux[i]       = 1'b0;
            downstream__wr_data_imux[i]     = {DATA_WIDTH{1'b0}};

            if (dec_if_sel[i]) begin
                downstream__req_vld_imux[i]  = upstream__req_vld;
                downstream__addr_imux[i]     = upstream__addr;
                downstream__wr_en_imux[i]    = upstream__wr_en;
                downstream__rd_en_imux[i]    = upstream__rd_en;
                downstream__wr_data_imux[i]  = upstream__wr_data;
            end
        end
    end

    // generate address offset and forward other signals
    //      for regdisp, generate absolute address
    //      for regslv, generate address offset
    //      for 3rd party IP, generate absolute address
    //      for external memory, generate address offset
    // there are two methods to convert absolute address to offset,
    // which depends on the base address alignment:
    //      1. base_addr = N * pow(2, ceil(log2(total_size))):
    //          simply set several higher bits to 0 by slicing
    //      2. otherwise:
    //          subtract base address from absolute address by generating a subtractor
    always_comb begin
        for (integer i = 0; i < FORWARD_NUM; i = i + 1) begin
            downstream__req_vld_conv[i]     = downstream__req_vld_imux[i];
            downstream__wr_en_conv[i]       = downstream__wr_en_imux[i];
            downstream__rd_en_conv[i]       = downstream__rd_en_imux[i];
            downstream__wr_data_conv[i]     = downstream__wr_data_imux[i];
        end
    end

    {%- for child in disp_node.children(unroll=True, skip_not_present=False) -%}
    {%- if use_abs_addr(child) %}
    {{"assign  downstream__addr_conv[%d] = downstream__addr_imux[%d];"|format(loop.index0,
                                                                             loop.index0)}}
    {%- elif is_aligned(child) %}
    {{"assign  downstream__addr_conv[%d] = {%d'b0, downstream__addr_imux[%d][%d:0]};"|format(loop.index0,
                                                                                            addr_width-valid_bit(child),
                                                                                            loop.index0,
                                                                                            valid_bit(child)-1)}}
    {%- else %}
    {{"assign  downstream__addr_conv[%d] = downstream__addr_imux[%d] - %d'h%x;"|format(loop.index0,
                                                                                      loop.index0,
                                                                                      addr_width,
                                                                                      child.absolute_address)}}
    {%- endif %}
    {%- endfor %}

    // optionally insert forwarding flip-flops
    genvar cnt;
    generate
        for (cnt = 0; cnt < FORWARD_NUM; cnt = cnt + 1) begin: g_forward_dff
            if (INSERT_FORWARD_DFF[cnt]) begin: g_with_out_dff
                always @(posedge clk or negedge rst_n) begin
                    if (!rst_n) begin
                        downstream__req_vld_ff[cnt]     <= 1'b0;
                        downstream__addr_ff[cnt]        <= {ADDR_WIDTH{1'b0}};
                        downstream__wr_en_ff[cnt]       <= 1'b0;
                        downstream__rd_en_ff[cnt]       <= 1'b0;
                        downstream__wr_data_ff[cnt]     <= {DATA_WIDTH{1'b0}};
                    end
                    else begin
                        downstream__req_vld_ff[cnt]     <= downstream__req_vld_conv[cnt];
                        downstream__addr_ff[cnt]        <= downstream__addr_conv[cnt];
                        downstream__wr_en_ff[cnt]       <= downstream__wr_en_conv[cnt];
                        downstream__rd_en_ff[cnt]       <= downstream__rd_en_conv[cnt];
                        downstream__wr_data_ff[cnt]     <= downstream__wr_data_conv[cnt];
                    end
                end
            end
            else begin: g_wo_out_dff
                assign downstream__req_vld_ff[cnt]      = downstream__req_vld_conv[cnt];
                assign downstream__addr_ff[cnt]         = downstream__addr_conv[cnt];
                assign downstream__wr_en_ff[cnt]        = downstream__wr_en_conv[cnt];
                assign downstream__rd_en_ff[cnt]        = downstream__rd_en_conv[cnt];
                assign downstream__wr_data_ff[cnt]      = downstream__wr_data_conv[cnt];
            end
        end
    endgenerate

    {% for child in disp_node.children(unroll=True, skip_not_present=False) %}
        {% set child_name = get_inst_name(child) %}
        {% if isinstance(child, MemNode) %}
            reg_native_if2mem #(
                .CDC_ENABLE({{has_cdc(child)}}),
                .BUS_DATA_WIDTH(DATA_WIDTH),
                .BUS_ADDR_WIDTH(ADDR_WIDTH),
                .ADDR_VALID_WIDTH({{valid_bit(child)}}),
                .MEM_DATA_WIDTH({{get_entry_width(child)}}),
                .MEM_ADDR_WIDTH({{get_addr_width(child)}})
            )
            reg_native_if2mem (
                .native_clk(clk),
                .native_rst_n(rst_n),
                .soft_rst(soft_rst_o),
                .mem_clk({{child_name}}_clk),
                .mem_rst_n({{child_name}}_rst_n)
                .req_vld(),
                .ack_vld(),
                .addr(),
                .wr_en(),
                .rd_en(),
                .wr_data(),
                .rd_data(),
                .mem_req_vld(),
                .mem_ack_vld()
                .mem_addr(),
                .mem_wr_en(),
                .mem_rd_en(),
                .mem_wr_data(),
                .mem_rd_data()
            );
        {% endif %}
    {% endfor %}

    // generate forward output interface


    /**************************************************************************
    ** backward datapath
    **************************************************************************/

    // backward multiplexor for rd_data and ack_vld
    assign  upstream__ack_vld_mux   = (| downstream__ack_vld) | dec_dummy_reg_sel;
    always_comb begin
        upstream__rd_data_mux = {DATA_WIDTH{1'b0}};
        if (!dec_dummy_reg_sel)
            for (integer i = 0; i < FORWARD_NUM; i = i + 1) begin
                if (downstream__ack_vld[i]) begin
                    upstream__rd_data_mux   = downstream__rd_data[i];
                end
            end
    end

    // optionally insert backward flip-flops after data passes through mux
    generate
        if (INSERT_BACKWARD_DFF) begin: g_with_in_dff
            always @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    upstream__ack_vld_ff    <= 1'b0;
                    upstream__rd_data_ff    <= {DATA_WIDTH{1'b0}};
                end
                else begin
                    upstream__ack_vld_ff    <= upstream__ack_vld_mux;
                    upstream__rd_data_ff    <= upstream__rd_data_mux;
                end
            end
        end
        else begin: g_wo_in_dff
            assign upstream__ack_vld_ff     = upstream__ack_vld_mux;
            assign upstream__rd_data_ff     = upstream__rd_data_mux;
        end
    endgenerate

endmodule